#!/usr/bin/env python3
# coding=utf-8

""" fumarolePlumeModel.py

Provides solutions to the model of Aubry et al (2017a)* which models the 
variation of volume flux, q, momentum flux, m, buoyancy flux, f, and plume 
angle, :math: `\\theta' which describe the rise of a buoyant plume subject to a side 
wind. 

Provided functions:
-------------------
- derivs
    Description of the forward model.
- wind
    Wind at altitude, z.
- objectiveFn
    Misfit function between the synthetic and "experimental" data.
- gradient
    Difference between the objective function for the current and test 
    solutions divided by the step in source condition values.  
- newConditions
    new source condition values based on the gradient from the previous 
    iteration via a Newton-Raphson process, i.e. 
        V0 = V0old - objectiveFn / gradient

Model description:
------------------
dx/ds = \cos(\\theta), dz/ds = \sin(\\theta),                    (4)
d(\\rho u r**2)/ds = 2 \\rho_a r u_e,                            (5)
d(\\rho u**2 r**2)/ds = (\\rho_a - \\rho) g r**2 \\sin(\\theta) 
    + w\\cos(\\theta) d(\\rho u r**2)/ds                          (6)
(\\rho u**2 r**2) d\\theta/ds = (\\rho_a - \\rho) g r**2 \\cos(\\theta) 
    - w\\sin(\\theta) d(\\rho u r**2)/ds                          (7)
d(g'ur**2)/ds = -N**2 u r**2 \\sin(\\theta),                     (8)

with
    g'  = g (\\rho_a - \\rho) / \\rho_a,
    u_e = \\alpha_e |u - w\\sin\\theta| + \\beta_e |w\\cos\\theta|
    N   = \\sqrt{-g/\\rho_0 d\\rho/dz}

Note that \\theta is measured relative to the horizontal plane.  

Applying the Boussinesq approximation (density variations are small enough to 
be negligible, except when a density term is multiplied by gravity) and upon 
making the following substitutions:
q = u r**2, m = u**2 r**2, f = g' u r**2,
we obtain
dq/ds = 2 q/\\sqrt{m} (\\alpha_e\\abs{m/q - w\\cos\\theta} 
	+ \beta_e\\abs{w\\sin\\theta})
dm/ds = fq/m\\sin\\theta + w\\cos\\theta dq/ds
df/ds = -N**2 \\sqrt{m} \\sin\\theta
d\theta/ds = fq/m**2\\cos\\theta - w/m\\sin\\theta dq/ds

References:
-----------
* Aubry, T. J., Carazzo, G., & Jellinek, A. M. (2017a). 
Turbulent entrainment into volcanic plumes: new constraints from laboratory
experiments on buoyant jets rising in a stratified crossflow. 
Geophys. Res. Lett., 44, 10,198--10,207.
https://dx.doi.org/10.1002/2017GL075069

see also:
Aubry, T. J., Jellinek, A. M., Carazzo, G., Gallo, R., Hatcher, K., 
Dunning, J. (2017b)
A new analytical scaling for turbulent wind-bent plumes: comparison of scaling 
laws with analog experiments and a new database of eruptive conditions for 
predicting the height of volcanic plumes
J. Volcanol. Geotherm. Res., 343, 233--251
http://dx.doi.org/10.1016/j.jvolgeores.2017.07.006

Woodhouse, M. J., A. J. Hogg, J. C. Phillips, and R. S. J. Sparks (2013)
Interaction between volcanic plumes and wind during the 2010 Eyjafjallaj\"okull
eruption, Iceland
J. Geophys. Res. Solid Earth, 118, 92--109
https://dx.doi.org/10.1029/2012JB009592

changes log:
------------
2018-06-25      Clipping model range to be equal to the experimental data
2018-06-26      Introduced command line option to plot data.  
                Introduced "main()" function to contain the bod
                
to do:
------
- Calculate experimental plume widths etc. in local reference (i.e. rotated)
  reference frame.
- Interpolate model data to be evaluated at same points as the experimental 
  data.
- Compare experimental and model data.
- Something odd happening in models of most expts: predicted plume trajectory
  changes direction quite abruptly.  Derivitives (theta) change sign here.
  Stop the calculation at this point?xs
"""

from scipy.integrate import ode
from scipy.interpolate import interp1d
from scipy.io.matlab import loadmat
from bentPlumeAnalyser import (plumeTrajectory,
                               distAlongPath,
                               plumeAngle)

import numpy as np
import matplotlib.pyplot as plt
import os, sys
import pandas

# Set matplotlib font to be "computer modern" and use TeX rendering
font = {'family' : 'serif',
        'serif': ['computer modern roman']}
#        'fontsize': 16}
# plt.rc('font', **font)
# plt.rc('text', usetex=True)

eps         = 1e-3
scaleFactor = 38
pathname    = 'Documents/PythonScripts/fumarolePlumeModel/data/'

# PHYSICAL CONSTANTS
g = 981                     # CGS

    
def derivs(s, V, p=(.09, .6, .1, 1., None)):
    """ 
    Description of the forward model.  Returns the derivatives of the state 
    vector, V, for the Aubry et al., 2017 (GRL) wind-bent plume model.  
    V contains the following state variables:
    q           volume flux (specific mass flux) = b**2 u
    m           specific momentum flux = b**2 u**2
    f           specific buoyancy flux = b**2 u g' 
    :math: `\\theta'      local deflection of the plume axis with respect to vertical

    
    Parameters
    ----------
    s	distance along the plume axis
    V   state variable consisting of q, m, f and :math: `\\theta'
    p   tuple containing model parameters:
        alpha   perpendicular entrainment coefficient (default = 0.09)
        beta    wind entrianment coefficient (0.6)
        N       Brunt-Väisälä frequency for the stratified environment (0.1)
        m       Devenish's coefficient, used in calculating u_e (1.0)
        w       "wind" option.  If None, the function wind will be called.
        
        Default parameters are as defined in GCs email to me

    Returns
    -------
    dVds	an array containing the derivatives

    Changes log
    -----------
    2018-06-25  swapped np.sqrt(m) term for q in df/ds (see Aubry et al.)
	
    """
    q, m, f, theta = V
    b, u, gp = q / np.sqrt(m), m / q, f / q
    alpha, beta, N, m, w = p

    # Get the wind speed at the current altitude
    if w is None:
        w = wind(s, V)

    # print(q, m, f, theta)
    # calculate the entrainment velocity
    u_e = ((alpha * abs(u - w * np.cos(theta))**m)
		   + (beta * abs(w * np.sin(theta)))**m) ** (1./m)
    #print(s, u_e)

    # Define the derivatives
    dqds     = 2. * b * u_e
    dmds     = f * q / m * np.sin(theta) + w * np.cos(theta) * dqds
    dfds     = -N**2 * q * np.sin(theta) 
    dthetads = f * q / m**2 * np.cos(theta) - w / m * np.sin(theta) * dqds

    dVds    = np.zeros(4)
    dVds[0] = dqds
    dVds[1] = dmds
    dVds[2] = dfds
    dVds[3] = dthetads

    return dVds


def wind(s, V):
    """ 
    Functions that define the wind at altitude, z.
    
    Currently a constant value is returned
    """

    theta = V[3]
    z = s * np.sin(theta)
    return z * .01


def objectiveFn(Vexp, Vsyn, sigma=None, p=(.09, .6, .1, 1., None)):
    """
    Returns the objective (misfit) function as the sum of square differences
    between the synthetic and "experimental" data
    
    Parameters
    ----------
        Vsyn : array like
            state vector of sythetic (model) data
        Vexp : array like	
            state vector of experimental (or natural) data
        p : tuple or array like
            vector of state variables
        sigma : array like
            standard deviations of the experimental data for weighting.  
    """

    # If no std dev is provided for the experimental data, set unit weights.
    if sigma is None:
        sigma = np.ones_like(Vexp)
        sigmaFlag = False		
    else:
        sigmaFlag = True

    #print("Expt. errors present: ", sigmaFlag)
        
    # Check that the synthetic and experimental data are of the same dimension
    # then define a residual (difference).
    if len(Vsyn.ravel()) == len(Vexp.ravel()):
        r = Vsyn - Vexp
    else:
        raise Warning('input vectors must be of the same dimension')
	
    if sigma.ndim == 1:  # Estimate the Chi**2 variable
        objFn = (np.divide(r, sigma)**2).sum()
    elif sigma.ndim == 2:
        # In this case, sigma is interpreted to be the covarance matrix of
        # errors in the "y" data.
        # Note that the "@" syntax is not recognised for python < 3.5
        # In this case use r.T.dot(invSig).dot(r)
        invSig = np.linalg.inv(sigma)
        objFn = r.T @ np.linalg.inv(sigma) @ r  
        # objFn = r.T.dot(invSig).dot(r)
    else:
        raise Warning('Covariance matrix of unknown dimensions')
	#print(objFn)

    if not sigmaFlag:
        # Degrees of freedom = number of data points - number of model params
        DOF = len(Vexp) - len(p)
        objFn /= DOF

    return objFn


def gradient(V0old, objFnOld):
    """
    Runs the solver to obtain a solution at a set of "test" source conditions.  
    The gradient of the misfit function is then returned as the difference 
    between the objective function for the current and test solutions divided 
    by the step in source condition values.  Clearly, the returned gradient is 
    of the same dimension as the state variable.
    """

    V0 = V0old + eps * np.ones_like(V0old)

    return (objFnOld - objFn) / (eps * np.ones_like(V0old))


def newConditions(V0old, objFn, gradient):
    """
    Returns the new source condition values based on the gradient from the
    previous iteration via a Newton-Raphson process, i.e.
    V0 = V0old - objectiveFn / gradient

    """
    return Vold - np.divide(objFn, gradient)


def loadICsParameters(pathname, run):
    """ 
    Returns initial conditions and model parameters determined from CGTA's 
    experimental data
    """
    filename = pathname + 'ExpPlumes_for_Dai/TableA1.xlsx'
    # Load all the data (in CGS units)
    df = pandas.read_excel(filename, sheet_name='CGSdata', skiprows=1, 
                           names=('run','rhoa','rhoa_2sig','N','N_2sig', 
                                  'rho0', 'rho0_2sig', 'U0', 'U0_2sig',
                                  'W', 'W_2sig', 'gp', 'gp_2sig', 
                                  'q0', 'q0_2sig', 'm0', 'm0_2sig',
                                  'f0', 'f0_2sig', 'Ri0', 'Ri0_2sig', 
                                  'Wstar', 'Wstar_2sig'))
    params = pandas.read_excel(filename, sheet_name='CGSparameters')

    # Define source conditions
    expt  = df.loc[df['run'] == run]
    rhoa0 = expt['rhoa'].values[0]
    rho0  = expt['rho0'].values[0]
    N     = expt['N'].values[0]
    u0    = expt['U0'].values[0]
    W     = expt['W'].values[0]
    r0    = params[params['property'] == 'nozzleSize'].value.values[0]
    
    gp0 = -(rhoa0 - rho0) / rhoa0 * g
        
    q0 = r0**2 * u0 
    m0 = r0**2 * u0**2 
    f0 = gp0 * q0
    theta0 = np.pi / 2.

    V0 = np.array([q0, m0, f0, theta0])
    # Define parameters to pass to derivs function.  Tuple p contains:
    # alpha, beta, N, m, w
    p  = (.09, .6, N, 1., W)
    return V0, p


def loadExptData(pathname, run):
    '''
	parameters
	pathname
	run
	'''
    # Load the experimental data and image
    dataDirName = pathname + 'ExpPlumes_for_Dai/exp%02d/' % run
    # load the experimental image
    data = np.flipud(loadmat(dataDirName + 'gsplume.mat')['gsplume'])
    # Load the locations of the centre of the plume (values in pixels)
    xexp = loadmat(dataDirName + 'xcenter.mat')['xcenter'][0]
    zexp = loadmat(dataDirName + 'zcenter.mat')['zcenter'][0]
    
    # Define the pixel coordinates of the origin as the first points in x & z
    origin = (xexp[0], zexp[0])
    # Now calculate the world extent of the data, using a conversion factor 
    # There's probably some neater and more pythonic way of calculating the
    # world extent list but at least it works as is.
    extentInPix = [0, data.shape[1], 0, data.shape[0]]
    extent = np.array([(extentInPix[:2] - origin[0])/scaleFactor,
                       (origin[1] - extentInPix[2:])/scaleFactor])
    extent = extent.flatten().tolist()

    # Convert experimental trajectories to physical units
    xexp = (xexp - xexp[0]) / scaleFactor
    zexp = (zexp[0] - zexp) / scaleFactor
    return data, xexp, zexp, extent


if __name__ == '__main__':
    # Look for command line arguments that tell us which experimental run
    # to analyse.  If the command line argument is 'all', set allFlag to True
    # and run the whole set.  If 
    allFlag = False
    run     = None
    if len(sys.argv) >= 2:
        run = sys.argv[1]
        if run == 'all':
            allFlag = True
        else:
            run = int(run)
        if len(sys.argv) == 3:
            plotResults = sys.argv[2]
            if plotResults == 'True':
                plotResults = True
            if plotResults == 'False':
                plotResults = False
        else:
            plotResults = True  # Default behaviour is to print the solution
    else:
        run = 3                 # Default expt
        plotResults = True      # Default behaviour is to print the solution
    # Test if plotResults is a boolean
    if not isinstance(plotResults, bool):
        raise TypeError('plotReults must be a boolean')

    # Form initial conditions and model parameters from CGTA expt data
    V0, p = loadICsParameters(pathname, run)

    # Define state vector and axial distance
    V  = []
    s  = []
    V.append(V0)
    s.append(0.)

    # Define the individual variables - these will be calculated at run time
    q, m, f, theta = [], [], [], []
    q0, m0, f0, theta0 = V0
    q.append(q0)
    m.append(m0)
    f.append(f0)
    theta.append(theta0)

    r = ode(derivs).set_integrator('lsoda', nsteps=1e6)
    r.set_initial_value(V0, 0)
    r.set_f_params(p)           # Set non default values for p

    t1 = 30.                    # Domain of integration 
    dt =   .1                   # Integration step
	
    while r.successful() and r.t < t1 and m[-1] >= 0.:
        r.integrate(r.t + dt)
        V.append(r.y)
        s.append(r.t)
        q_, m_, f_, theta_ = r.y
        q.append(q_)
        m.append(m_)
        f.append(f_)
        theta.append(theta_)


    # Convert variables to numpy arrays for convenience
    s, V, q, m, f, theta = (np.array(s), np.array(V), np.array(q), 
                            np.array(m), np.array(f), np.array(theta))

    filename = pathname + 'fumarolePlumeModel_expt%02d.csv' % run
    try:
        if not os.path.isfile(filename):
            with open(filename, 'w') as fido:
                fido.write('# Solution to run % 2d\n' % run)
                for _s, line in zip(s, V):
                    fido.write('%6.2f,%8.4f,%8.4f,%8.4f,%8.4f\n' % (_s,
							            line[0],
                                                                    line[1],
							            line[2],
                                                                    line[3]))
    except FileNotFoundError:
        print('Directory does not exist')

    # Convert plume flux parameters into basic params
    b, u, gp = q / np.sqrt(m), m / q, f / q

    # Calculate the model predictions
    xmod, zmod = [0.], [0.]
    ds_ = np.diff(s)
    for (ds, th) in zip(ds_, theta):
        xmod.append(xmod[-1] + ds * np.cos(th))
        zmod.append(zmod[-1] + ds * np.sin(th))

    # Load experimental data and image from file
    data, xexp, zexp, extent = loadExptDatarun()
    
    # Distance along plume axis and plume angle
    sexp     = distAlongPath(xexp, zexp)
    thetaexp = plumeAngle(xexp, zexp)

    if plotResults:
        # Plot the image, experimental and model data
        plt.close('all')
        fig, ax = plt.subplots(1, 3, figsize=(14, 5))
        # Plume greyscale intensity image 
        ax[0].imshow(data, extent=extent, cmap=plt.cm.gray)
        ax[0].set_xlabel(r'$x$/[cm]')
        ax[0].set_ylabel(r'$z$/[cm]')
        XLim = ax[0].get_xlim()
        YLim = ax[0].get_ylim()
        # Experimentally-determined plume axis trajectory
        ax[0].plot(xexp, zexp, 'r--', label='expt', lw=2)
        # Model plume axis trajectory
        ax[0].plot(xmod, zmod, 'g-', label='model', lw=2)
        ax[0].set_xlim(XLim)
        ax[0].set_ylim(YLim[::-1])
        ax[0].legend(loc=4, framealpha=.6)
        ax[0].grid(True)

        # Normalise dimensional solutions by source value (or mean?)
        ax[1].plot(b/b[0], s, '-')
        ax[1].plot(u/u[0], s, '-')
        ax[1].plot(gp/gp[0], s, '-') 
        ax[1].plot(theta, s, '--')
        # Create interpolation structures based on the model solution which
        # will be used to recast the model at the experimental data points.
        # PLUME ANGLE
        f = interp1d(s, V[:,3])
        ax[1].plot(thetaexp, sexp, '-', c='C3')
        ax[1].set_title('Differences between model and expt data')
        ax[1].legend((r'$b/b_0$',
                      r'$\bar{u}/\bar{u}_0$',
                      r'$g/g_0$',
                      r'$\theta$',
                      r'$\theta_{\mathrm{exp}}$'),
                     loc=1, framealpha=.6)
        ax[1].grid(True)
        ax[1].set_xlabel(r'Plume parameter/[-]')
        ax[1].set_ylabel(r'$s$/[cm]')

        dVds = []
        for s_, V_ in zip(s, V):                                               
            dVds.append(derivs(s_, V_)) 
        dVds = np.array(dVds)

        ax[2].plot(V, s, '-')
        ax[2].set_prop_cycle(None)
        ax[2].plot(dVds, s, '--')
        ax[2].grid()
        ax[2].set_xlim((-3, 33))

        ax[2].legend(('q', 'm', 'f', r'$\theta$',
                      'dq/ds', 'dm/ds', 'df/ds', r'd$\theta$/ds'),
                     loc=1)
        ax[2].set_xlabel(r'Plume parameter/[-]')
        ax[2].set_ylabel(r'$s$/[cm]')
        ax[2].set_title('Plume parameters and their derivatives')

        # # Create interpolation structures based on the model solution which
        # # will be used to recast the model at the experimental data points.
        # # PLUME ANGLE
        # f = interp1d(s, V[:,3])
        # ax[3].plot((thetaexp - f(sexp))**2, sexp, '-', label='plume angle')
        # ax[3].set_title('Differences between model and expt data')

        plt.show()
